using System;
using System.Net;
using System.Collections.Generic;

using Newtonsoft.Json;


// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using CryptoCompare;
//
//    var welcome = Welcome.FromJson(jsonString);
/*
namespace CryptoCompare
{
    public class CoinListResult
    {
        [JsonProperty("Response")]
        public string Response { get; set; }

        [JsonProperty("Message")]
        public string Message { get; set; }

        [JsonProperty("BaseImageUrl")]
        public string BaseImageUrl { get; set; }

        [JsonProperty("BaseLinkUrl")]
        public string BaseLinkUrl { get; set; }

        [JsonProperty("DefaultWatchlist")]
        public DefaultWatchlist DefaultWatchlist { get; set; }

        [JsonProperty("Data")]
        public Dictionary<string, Coin> Data { get; set; }

        [JsonProperty("Type")]
        public long Type { get; set; }
    }

    public class Coin
    {
        string BasePath = "https://www.cryptocompare.com";

        [JsonProperty("Id")]
        public string Id { get; set; }

        [JsonProperty("Url")]
        public string Url { get; set; }

        [JsonProperty("ImageUrl")]
        public string ImageUrl { get; set; }

        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("Symbol")]
        public string Symbol { get; set; }

        [JsonProperty("CoinName")]
        public string CoinName { get; set; }

        [JsonProperty("FullName")]
        public string FullName { get; set; }

        [JsonProperty("Algorithm")]
        public string Algorithm { get; set; }

        [JsonProperty("ProofType")]
        public string ProofType { get; set; }

        [JsonProperty("FullyPremined")]
        public string FullyPremined { get; set; }

        [JsonProperty("TotalCoinSupply")]
        public string TotalCoinSupply { get; set; }

        [JsonProperty("PreMinedValue")]
        public string PreMinedValue { get; set; }

        [JsonProperty("TotalCoinsFreeFloat")]
        public string TotalCoinsFreeFloat { get; set; }

        [JsonProperty("SortOrder")]
        public int SortOrder { get; set; }

        [JsonProperty("Sponsored")]
        public bool Sponsored { get; set; }

        [JsonIgnore]
        public string CoinImage { get => $"{ this.BasePath }{this.ImageUrl}"; }
    }

    public class DefaultWatchlist
    {
        [JsonProperty("CoinIs")]
        public string CoinIs { get; set; }

        [JsonProperty("Sponsored")]
        public string Sponsored { get; set; }
    }

    public class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
        };
    }

}

    */


namespace CryptoCompare
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class CoinListResult
    {
        [JsonProperty("Response")]
        public string Response { get; set; }

        [JsonProperty("Message")]
        public string Message { get; set; }

        [JsonProperty("Data")]
        public Dictionary<string, Coin> Data { get; set; }

        [JsonProperty("BaseImageUrl")]
        public Uri BaseImageUrl { get; set; }

        [JsonProperty("BaseLinkUrl")]
        public Uri BaseLinkUrl { get; set; }

        [JsonProperty("RateLimit")]
        public RateLimit RateLimit { get; set; }

        [JsonProperty("HasWarning")]
        public bool HasWarning { get; set; }

        [JsonProperty("Type")]
        public long Type { get; set; }
    }

    public partial class Coin
    {
        string BasePath = "https://www.cryptocompare.com";

        [JsonIgnore]
        public string CoinImage { get => $"{ this.BasePath }{this.ImageUrl}"; }

        [JsonIgnore]
        public string CoinOverview { get => $"{ this.BasePath }{this.Url}"; }

        [JsonProperty("Id")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Id { get; set; }

        [JsonProperty("Url")]
        public string Url { get; set; }

        [JsonProperty("ImageUrl", NullValueHandling = NullValueHandling.Ignore)]
        public string ImageUrl { get; set; }

        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("Symbol")]
        public string Symbol { get; set; }

        [JsonProperty("CoinName")]
        public string CoinName { get; set; }

        [JsonProperty("FullName")]
        public string FullName { get; set; }

        [JsonProperty("Algorithm")]
        public string Algorithm { get; set; }

        [JsonProperty("ProofType")]
        public BuiltOn ProofType { get; set; }

        [JsonProperty("FullyPremined")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long FullyPremined { get; set; }

        [JsonProperty("TotalCoinSupply")]
        public string TotalCoinSupply { get; set; }

        [JsonProperty("BuiltOn")]
        public BuiltOn BuiltOn { get; set; }

        [JsonProperty("SmartContractAddress")]
        public string SmartContractAddress { get; set; }

        [JsonProperty("PreMinedValue")]
        public PreMinedValue PreMinedValue { get; set; }

        [JsonProperty("TotalCoinsFreeFloat")]
        public PreMinedValue TotalCoinsFreeFloat { get; set; }

        [JsonProperty("SortOrder")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long SortOrder { get; set; }

        [JsonProperty("Sponsored")]
        public bool Sponsored { get; set; }

        [JsonProperty("IsTrading")]
        public bool IsTrading { get; set; }

        [JsonProperty("TotalCoinsMined", NullValueHandling = NullValueHandling.Ignore)]
        public double? TotalCoinsMined { get; set; }

        [JsonProperty("BlockNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? BlockNumber { get; set; }

        [JsonProperty("NetHashesPerSecond", NullValueHandling = NullValueHandling.Ignore)]
        public double? NetHashesPerSecond { get; set; }

        [JsonProperty("BlockReward", NullValueHandling = NullValueHandling.Ignore)]
        public double? BlockReward { get; set; }

        [JsonProperty("BlockTime", NullValueHandling = NullValueHandling.Ignore)]
        public long? BlockTime { get; set; }
    }

    public partial class RateLimit
    {
    }

    public enum PreMinedValue { Consortium, DPoC, DPoR, DPoS, DPoSLPoS, DPoWPoW, Dpos, EPoW, HPoW, LPoS, Lft, LimitedConfidenceProofOfActivity, MFba, NA, PoA, PoB, PoBPoS, PoBh, PoC, PoI, PoP, PoPPoVPoQ, PoPp, PoR, PoS, PoSLPoS, PoSPoB, PoSPoD, PoSPoP, PoSPoW, PoSPoWPoT, PoSign, PoSt, PoW, PoWAndPoS, PoWDPoW, PoWHiPoS, PoWNPoS, PoWPoMPoSii, PoWPoS, PoWPoSPoC, PoWPoW, PoWPoZ, PoWt, Pos, PowPoS, PowPoSc, PreMinedValuePoS, PreMinedValuePoWPoS, ProofOfAuthority, ProofOfOwnership, ProofOfStake, PurplePoWPoS, ScryptAdaptiveNAsicResistant, TPoS, Tangle, ZeroKnowledgeProof };

    public partial struct BuiltOn
    {
        public PreMinedValue? Enum;
        public long? Integer;

        public static implicit operator BuiltOn(PreMinedValue Enum) => new BuiltOn { Enum = Enum };
        public static implicit operator BuiltOn(long Integer) => new BuiltOn { Integer = Integer };
    }

    public partial class Welcome
    {
        public static CoinListResult FromJson(string json) => JsonConvert.DeserializeObject<CoinListResult>(json, CryptoCompare.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Welcome self) => JsonConvert.SerializeObject(self, CryptoCompare.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                BuiltOnConverter.Singleton,
                PreMinedValueConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class BuiltOnConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BuiltOn) || t == typeof(BuiltOn?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case " PoW/PoS":
                            return new BuiltOn { Enum = PreMinedValue.PurplePoWPoS };
                        case "Consortium":
                            return new BuiltOn { Enum = PreMinedValue.Consortium };
                        case "DPOS":
                            return new BuiltOn { Enum = PreMinedValue.Dpos };
                        case "DPoC":
                            return new BuiltOn { Enum = PreMinedValue.DPoC };
                        case "DPoR":
                            return new BuiltOn { Enum = PreMinedValue.DPoR };
                        case "DPoS":
                            return new BuiltOn { Enum = PreMinedValue.DPoS };
                        case "DPoS/LPoS":
                            return new BuiltOn { Enum = PreMinedValue.DPoSLPoS };
                        case "HPoW":
                            return new BuiltOn { Enum = PreMinedValue.HPoW };
                        case "LFT":
                            return new BuiltOn { Enum = PreMinedValue.Lft };
                        case "LPoS":
                            return new BuiltOn { Enum = PreMinedValue.LPoS };
                        case "Limited Confidence Proof-of-Activity ":
                            return new BuiltOn { Enum = PreMinedValue.LimitedConfidenceProofOfActivity };
                        case "N/A":
                            return new BuiltOn { Enum = PreMinedValue.NA };
                        case "POBh":
                            return new BuiltOn { Enum = PreMinedValue.PoBh };
                        case "PoA":
                            return new BuiltOn { Enum = PreMinedValue.PoA };
                        case "PoB":
                            return new BuiltOn { Enum = PreMinedValue.PoB };
                        case "PoB/PoS":
                            return new BuiltOn { Enum = PreMinedValue.PoBPoS };
                        case "PoC":
                            return new BuiltOn { Enum = PreMinedValue.PoC };
                        case "PoI":
                            return new BuiltOn { Enum = PreMinedValue.PoI };
                        case "PoP":
                            return new BuiltOn { Enum = PreMinedValue.PoP };
                        case "PoP/PoV/PoQ":
                            return new BuiltOn { Enum = PreMinedValue.PoPPoVPoQ };
                        case "PoPP":
                            return new BuiltOn { Enum = PreMinedValue.PoPp };
                        case "PoR":
                            return new BuiltOn { Enum = PreMinedValue.PoR };
                        case "PoS":
                            return new BuiltOn { Enum = PreMinedValue.PoS };
                        case "PoS ":
                            return new BuiltOn { Enum = PreMinedValue.PreMinedValuePoS };
                        case "PoS/LPoS":
                            return new BuiltOn { Enum = PreMinedValue.PoSLPoS };
                        case "PoS/PoB":
                            return new BuiltOn { Enum = PreMinedValue.PoSPoB };
                        case "PoS/PoD":
                            return new BuiltOn { Enum = PreMinedValue.PoSPoD };
                        case "PoS/PoP":
                            return new BuiltOn { Enum = PreMinedValue.PoSPoP };
                        case "PoS/PoW":
                            return new BuiltOn { Enum = PreMinedValue.PoSPoW };
                        case "PoS/PoW/PoT":
                            return new BuiltOn { Enum = PreMinedValue.PoSPoWPoT };
                        case "PoST":
                            return new BuiltOn { Enum = PreMinedValue.PoSt };
                        case "PoSign":
                            return new BuiltOn { Enum = PreMinedValue.PoSign };
                        case "PoW":
                            return new BuiltOn { Enum = PreMinedValue.PoW };
                        case "PoW and PoS":
                            return new BuiltOn { Enum = PreMinedValue.PoWAndPoS };
                        case "PoW/DPoW":
                            return new BuiltOn { Enum = PreMinedValue.PoWDPoW };
                        case "PoW/HiPoS":
                            return new BuiltOn { Enum = PreMinedValue.PoWHiPoS };
                        case "PoW/PoM/PoSII":
                            return new BuiltOn { Enum = PreMinedValue.PoWPoMPoSii };
                        case "PoW/PoS":
                            return new BuiltOn { Enum = PreMinedValue.PoWPoS };
                        case "PoW/PoS ":
                            return new BuiltOn { Enum = PreMinedValue.PreMinedValuePoWPoS };
                        case "PoW/PoS/PoC":
                            return new BuiltOn { Enum = PreMinedValue.PoWPoSPoC };
                        case "PoW/PoW":
                            return new BuiltOn { Enum = PreMinedValue.PoWPoW };
                        case "PoW/PoZ":
                            return new BuiltOn { Enum = PreMinedValue.PoWPoZ };
                        case "PoW/nPoS":
                            return new BuiltOn { Enum = PreMinedValue.PoWNPoS };
                        case "PoWT":
                            return new BuiltOn { Enum = PreMinedValue.PoWt };
                        case "Pos":
                            return new BuiltOn { Enum = PreMinedValue.Pos };
                        case "Pow/PoS":
                            return new BuiltOn { Enum = PreMinedValue.PowPoS };
                        case "Pow/PoSC":
                            return new BuiltOn { Enum = PreMinedValue.PowPoSc };
                        case "Proof of Authority":
                            return new BuiltOn { Enum = PreMinedValue.ProofOfAuthority };
                        case "Proof of Ownership":
                            return new BuiltOn { Enum = PreMinedValue.ProofOfOwnership };
                        case "Proof of Stake":
                            return new BuiltOn { Enum = PreMinedValue.ProofOfStake };
                        case "Scrypt-adaptive-N (ASIC resistant)":
                            return new BuiltOn { Enum = PreMinedValue.ScryptAdaptiveNAsicResistant };
                        case "TPoS":
                            return new BuiltOn { Enum = PreMinedValue.TPoS };
                        case "Tangle":
                            return new BuiltOn { Enum = PreMinedValue.Tangle };
                        case "Zero-Knowledge Proof":
                            return new BuiltOn { Enum = PreMinedValue.ZeroKnowledgeProof };
                        case "dPoW/PoW":
                            return new BuiltOn { Enum = PreMinedValue.DPoWPoW };
                        case "ePoW":
                            return new BuiltOn { Enum = PreMinedValue.EPoW };
                        case "mFBA":
                            return new BuiltOn { Enum = PreMinedValue.MFba };
                    }
                    long l;
                    if (Int64.TryParse(stringValue, out l))
                    {
                        return new BuiltOn { Integer = l };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type BuiltOn");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BuiltOn)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PreMinedValue.PurplePoWPoS:
                        serializer.Serialize(writer, " PoW/PoS");
                        return;
                    case PreMinedValue.Consortium:
                        serializer.Serialize(writer, "Consortium");
                        return;
                    case PreMinedValue.Dpos:
                        serializer.Serialize(writer, "DPOS");
                        return;
                    case PreMinedValue.DPoC:
                        serializer.Serialize(writer, "DPoC");
                        return;
                    case PreMinedValue.DPoR:
                        serializer.Serialize(writer, "DPoR");
                        return;
                    case PreMinedValue.DPoS:
                        serializer.Serialize(writer, "DPoS");
                        return;
                    case PreMinedValue.DPoSLPoS:
                        serializer.Serialize(writer, "DPoS/LPoS");
                        return;
                    case PreMinedValue.HPoW:
                        serializer.Serialize(writer, "HPoW");
                        return;
                    case PreMinedValue.Lft:
                        serializer.Serialize(writer, "LFT");
                        return;
                    case PreMinedValue.LPoS:
                        serializer.Serialize(writer, "LPoS");
                        return;
                    case PreMinedValue.LimitedConfidenceProofOfActivity:
                        serializer.Serialize(writer, "Limited Confidence Proof-of-Activity ");
                        return;
                    case PreMinedValue.NA:
                        serializer.Serialize(writer, "N/A");
                        return;
                    case PreMinedValue.PoBh:
                        serializer.Serialize(writer, "POBh");
                        return;
                    case PreMinedValue.PoA:
                        serializer.Serialize(writer, "PoA");
                        return;
                    case PreMinedValue.PoB:
                        serializer.Serialize(writer, "PoB");
                        return;
                    case PreMinedValue.PoBPoS:
                        serializer.Serialize(writer, "PoB/PoS");
                        return;
                    case PreMinedValue.PoC:
                        serializer.Serialize(writer, "PoC");
                        return;
                    case PreMinedValue.PoI:
                        serializer.Serialize(writer, "PoI");
                        return;
                    case PreMinedValue.PoP:
                        serializer.Serialize(writer, "PoP");
                        return;
                    case PreMinedValue.PoPPoVPoQ:
                        serializer.Serialize(writer, "PoP/PoV/PoQ");
                        return;
                    case PreMinedValue.PoPp:
                        serializer.Serialize(writer, "PoPP");
                        return;
                    case PreMinedValue.PoR:
                        serializer.Serialize(writer, "PoR");
                        return;
                    case PreMinedValue.PoS:
                        serializer.Serialize(writer, "PoS");
                        return;
                    case PreMinedValue.PreMinedValuePoS:
                        serializer.Serialize(writer, "PoS ");
                        return;
                    case PreMinedValue.PoSLPoS:
                        serializer.Serialize(writer, "PoS/LPoS");
                        return;
                    case PreMinedValue.PoSPoB:
                        serializer.Serialize(writer, "PoS/PoB");
                        return;
                    case PreMinedValue.PoSPoD:
                        serializer.Serialize(writer, "PoS/PoD");
                        return;
                    case PreMinedValue.PoSPoP:
                        serializer.Serialize(writer, "PoS/PoP");
                        return;
                    case PreMinedValue.PoSPoW:
                        serializer.Serialize(writer, "PoS/PoW");
                        return;
                    case PreMinedValue.PoSPoWPoT:
                        serializer.Serialize(writer, "PoS/PoW/PoT");
                        return;
                    case PreMinedValue.PoSt:
                        serializer.Serialize(writer, "PoST");
                        return;
                    case PreMinedValue.PoSign:
                        serializer.Serialize(writer, "PoSign");
                        return;
                    case PreMinedValue.PoW:
                        serializer.Serialize(writer, "PoW");
                        return;
                    case PreMinedValue.PoWAndPoS:
                        serializer.Serialize(writer, "PoW and PoS");
                        return;
                    case PreMinedValue.PoWDPoW:
                        serializer.Serialize(writer, "PoW/DPoW");
                        return;
                    case PreMinedValue.PoWHiPoS:
                        serializer.Serialize(writer, "PoW/HiPoS");
                        return;
                    case PreMinedValue.PoWPoMPoSii:
                        serializer.Serialize(writer, "PoW/PoM/PoSII");
                        return;
                    case PreMinedValue.PoWPoS:
                        serializer.Serialize(writer, "PoW/PoS");
                        return;
                    case PreMinedValue.PreMinedValuePoWPoS:
                        serializer.Serialize(writer, "PoW/PoS ");
                        return;
                    case PreMinedValue.PoWPoSPoC:
                        serializer.Serialize(writer, "PoW/PoS/PoC");
                        return;
                    case PreMinedValue.PoWPoW:
                        serializer.Serialize(writer, "PoW/PoW");
                        return;
                    case PreMinedValue.PoWPoZ:
                        serializer.Serialize(writer, "PoW/PoZ");
                        return;
                    case PreMinedValue.PoWNPoS:
                        serializer.Serialize(writer, "PoW/nPoS");
                        return;
                    case PreMinedValue.PoWt:
                        serializer.Serialize(writer, "PoWT");
                        return;
                    case PreMinedValue.Pos:
                        serializer.Serialize(writer, "Pos");
                        return;
                    case PreMinedValue.PowPoS:
                        serializer.Serialize(writer, "Pow/PoS");
                        return;
                    case PreMinedValue.PowPoSc:
                        serializer.Serialize(writer, "Pow/PoSC");
                        return;
                    case PreMinedValue.ProofOfAuthority:
                        serializer.Serialize(writer, "Proof of Authority");
                        return;
                    case PreMinedValue.ProofOfOwnership:
                        serializer.Serialize(writer, "Proof of Ownership");
                        return;
                    case PreMinedValue.ProofOfStake:
                        serializer.Serialize(writer, "Proof of Stake");
                        return;
                    case PreMinedValue.ScryptAdaptiveNAsicResistant:
                        serializer.Serialize(writer, "Scrypt-adaptive-N (ASIC resistant)");
                        return;
                    case PreMinedValue.TPoS:
                        serializer.Serialize(writer, "TPoS");
                        return;
                    case PreMinedValue.Tangle:
                        serializer.Serialize(writer, "Tangle");
                        return;
                    case PreMinedValue.ZeroKnowledgeProof:
                        serializer.Serialize(writer, "Zero-Knowledge Proof");
                        return;
                    case PreMinedValue.DPoWPoW:
                        serializer.Serialize(writer, "dPoW/PoW");
                        return;
                    case PreMinedValue.EPoW:
                        serializer.Serialize(writer, "ePoW");
                        return;
                    case PreMinedValue.MFba:
                        serializer.Serialize(writer, "mFBA");
                        return;
                }
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value.ToString());
                return;
            }
            throw new Exception("Cannot marshal type BuiltOn");
        }

        public static readonly BuiltOnConverter Singleton = new BuiltOnConverter();
    }

    internal class PreMinedValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PreMinedValue) || t == typeof(PreMinedValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case " PoW/PoS":
                    return PreMinedValue.PurplePoWPoS;
                case "Consortium":
                    return PreMinedValue.Consortium;
                case "DPOS":
                    return PreMinedValue.Dpos;
                case "DPoC":
                    return PreMinedValue.DPoC;
                case "DPoR":
                    return PreMinedValue.DPoR;
                case "DPoS":
                    return PreMinedValue.DPoS;
                case "DPoS/LPoS":
                    return PreMinedValue.DPoSLPoS;
                case "HPoW":
                    return PreMinedValue.HPoW;
                case "LFT":
                    return PreMinedValue.Lft;
                case "LPoS":
                    return PreMinedValue.LPoS;
                case "Limited Confidence Proof-of-Activity ":
                    return PreMinedValue.LimitedConfidenceProofOfActivity;
                case "N/A":
                    return PreMinedValue.NA;
                case "POBh":
                    return PreMinedValue.PoBh;
                case "PoA":
                    return PreMinedValue.PoA;
                case "PoB":
                    return PreMinedValue.PoB;
                case "PoB/PoS":
                    return PreMinedValue.PoBPoS;
                case "PoC":
                    return PreMinedValue.PoC;
                case "PoI":
                    return PreMinedValue.PoI;
                case "PoP":
                    return PreMinedValue.PoP;
                case "PoP/PoV/PoQ":
                    return PreMinedValue.PoPPoVPoQ;
                case "PoPP":
                    return PreMinedValue.PoPp;
                case "PoR":
                    return PreMinedValue.PoR;
                case "PoS":
                    return PreMinedValue.PoS;
                case "PoS ":
                    return PreMinedValue.PreMinedValuePoS;
                case "PoS/LPoS":
                    return PreMinedValue.PoSLPoS;
                case "PoS/PoB":
                    return PreMinedValue.PoSPoB;
                case "PoS/PoD":
                    return PreMinedValue.PoSPoD;
                case "PoS/PoP":
                    return PreMinedValue.PoSPoP;
                case "PoS/PoW":
                    return PreMinedValue.PoSPoW;
                case "PoS/PoW/PoT":
                    return PreMinedValue.PoSPoWPoT;
                case "PoST":
                    return PreMinedValue.PoSt;
                case "PoSign":
                    return PreMinedValue.PoSign;
                case "PoW":
                    return PreMinedValue.PoW;
                case "PoW and PoS":
                    return PreMinedValue.PoWAndPoS;
                case "PoW/DPoW":
                    return PreMinedValue.PoWDPoW;
                case "PoW/HiPoS":
                    return PreMinedValue.PoWHiPoS;
                case "PoW/PoM/PoSII":
                    return PreMinedValue.PoWPoMPoSii;
                case "PoW/PoS":
                    return PreMinedValue.PoWPoS;
                case "PoW/PoS ":
                    return PreMinedValue.PreMinedValuePoWPoS;
                case "PoW/PoS/PoC":
                    return PreMinedValue.PoWPoSPoC;
                case "PoW/PoW":
                    return PreMinedValue.PoWPoW;
                case "PoW/PoZ":
                    return PreMinedValue.PoWPoZ;
                case "PoW/nPoS":
                    return PreMinedValue.PoWNPoS;
                case "PoWT":
                    return PreMinedValue.PoWt;
                case "Pos":
                    return PreMinedValue.Pos;
                case "Pow/PoS":
                    return PreMinedValue.PowPoS;
                case "Pow/PoSC":
                    return PreMinedValue.PowPoSc;
                case "Proof of Authority":
                    return PreMinedValue.ProofOfAuthority;
                case "Proof of Ownership":
                    return PreMinedValue.ProofOfOwnership;
                case "Proof of Stake":
                    return PreMinedValue.ProofOfStake;
                case "Scrypt-adaptive-N (ASIC resistant)":
                    return PreMinedValue.ScryptAdaptiveNAsicResistant;
                case "TPoS":
                    return PreMinedValue.TPoS;
                case "Tangle":
                    return PreMinedValue.Tangle;
                case "Zero-Knowledge Proof":
                    return PreMinedValue.ZeroKnowledgeProof;
                case "dPoW/PoW":
                    return PreMinedValue.DPoWPoW;
                case "ePoW":
                    return PreMinedValue.EPoW;
                case "mFBA":
                    return PreMinedValue.MFba;
            }
            throw new Exception("Cannot unmarshal type PreMinedValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PreMinedValue)untypedValue;
            switch (value)
            {
                case PreMinedValue.PurplePoWPoS:
                    serializer.Serialize(writer, " PoW/PoS");
                    return;
                case PreMinedValue.Consortium:
                    serializer.Serialize(writer, "Consortium");
                    return;
                case PreMinedValue.Dpos:
                    serializer.Serialize(writer, "DPOS");
                    return;
                case PreMinedValue.DPoC:
                    serializer.Serialize(writer, "DPoC");
                    return;
                case PreMinedValue.DPoR:
                    serializer.Serialize(writer, "DPoR");
                    return;
                case PreMinedValue.DPoS:
                    serializer.Serialize(writer, "DPoS");
                    return;
                case PreMinedValue.DPoSLPoS:
                    serializer.Serialize(writer, "DPoS/LPoS");
                    return;
                case PreMinedValue.HPoW:
                    serializer.Serialize(writer, "HPoW");
                    return;
                case PreMinedValue.Lft:
                    serializer.Serialize(writer, "LFT");
                    return;
                case PreMinedValue.LPoS:
                    serializer.Serialize(writer, "LPoS");
                    return;
                case PreMinedValue.LimitedConfidenceProofOfActivity:
                    serializer.Serialize(writer, "Limited Confidence Proof-of-Activity ");
                    return;
                case PreMinedValue.NA:
                    serializer.Serialize(writer, "N/A");
                    return;
                case PreMinedValue.PoBh:
                    serializer.Serialize(writer, "POBh");
                    return;
                case PreMinedValue.PoA:
                    serializer.Serialize(writer, "PoA");
                    return;
                case PreMinedValue.PoB:
                    serializer.Serialize(writer, "PoB");
                    return;
                case PreMinedValue.PoBPoS:
                    serializer.Serialize(writer, "PoB/PoS");
                    return;
                case PreMinedValue.PoC:
                    serializer.Serialize(writer, "PoC");
                    return;
                case PreMinedValue.PoI:
                    serializer.Serialize(writer, "PoI");
                    return;
                case PreMinedValue.PoP:
                    serializer.Serialize(writer, "PoP");
                    return;
                case PreMinedValue.PoPPoVPoQ:
                    serializer.Serialize(writer, "PoP/PoV/PoQ");
                    return;
                case PreMinedValue.PoPp:
                    serializer.Serialize(writer, "PoPP");
                    return;
                case PreMinedValue.PoR:
                    serializer.Serialize(writer, "PoR");
                    return;
                case PreMinedValue.PoS:
                    serializer.Serialize(writer, "PoS");
                    return;
                case PreMinedValue.PreMinedValuePoS:
                    serializer.Serialize(writer, "PoS ");
                    return;
                case PreMinedValue.PoSLPoS:
                    serializer.Serialize(writer, "PoS/LPoS");
                    return;
                case PreMinedValue.PoSPoB:
                    serializer.Serialize(writer, "PoS/PoB");
                    return;
                case PreMinedValue.PoSPoD:
                    serializer.Serialize(writer, "PoS/PoD");
                    return;
                case PreMinedValue.PoSPoP:
                    serializer.Serialize(writer, "PoS/PoP");
                    return;
                case PreMinedValue.PoSPoW:
                    serializer.Serialize(writer, "PoS/PoW");
                    return;
                case PreMinedValue.PoSPoWPoT:
                    serializer.Serialize(writer, "PoS/PoW/PoT");
                    return;
                case PreMinedValue.PoSt:
                    serializer.Serialize(writer, "PoST");
                    return;
                case PreMinedValue.PoSign:
                    serializer.Serialize(writer, "PoSign");
                    return;
                case PreMinedValue.PoW:
                    serializer.Serialize(writer, "PoW");
                    return;
                case PreMinedValue.PoWAndPoS:
                    serializer.Serialize(writer, "PoW and PoS");
                    return;
                case PreMinedValue.PoWDPoW:
                    serializer.Serialize(writer, "PoW/DPoW");
                    return;
                case PreMinedValue.PoWHiPoS:
                    serializer.Serialize(writer, "PoW/HiPoS");
                    return;
                case PreMinedValue.PoWPoMPoSii:
                    serializer.Serialize(writer, "PoW/PoM/PoSII");
                    return;
                case PreMinedValue.PoWPoS:
                    serializer.Serialize(writer, "PoW/PoS");
                    return;
                case PreMinedValue.PreMinedValuePoWPoS:
                    serializer.Serialize(writer, "PoW/PoS ");
                    return;
                case PreMinedValue.PoWPoSPoC:
                    serializer.Serialize(writer, "PoW/PoS/PoC");
                    return;
                case PreMinedValue.PoWPoW:
                    serializer.Serialize(writer, "PoW/PoW");
                    return;
                case PreMinedValue.PoWPoZ:
                    serializer.Serialize(writer, "PoW/PoZ");
                    return;
                case PreMinedValue.PoWNPoS:
                    serializer.Serialize(writer, "PoW/nPoS");
                    return;
                case PreMinedValue.PoWt:
                    serializer.Serialize(writer, "PoWT");
                    return;
                case PreMinedValue.Pos:
                    serializer.Serialize(writer, "Pos");
                    return;
                case PreMinedValue.PowPoS:
                    serializer.Serialize(writer, "Pow/PoS");
                    return;
                case PreMinedValue.PowPoSc:
                    serializer.Serialize(writer, "Pow/PoSC");
                    return;
                case PreMinedValue.ProofOfAuthority:
                    serializer.Serialize(writer, "Proof of Authority");
                    return;
                case PreMinedValue.ProofOfOwnership:
                    serializer.Serialize(writer, "Proof of Ownership");
                    return;
                case PreMinedValue.ProofOfStake:
                    serializer.Serialize(writer, "Proof of Stake");
                    return;
                case PreMinedValue.ScryptAdaptiveNAsicResistant:
                    serializer.Serialize(writer, "Scrypt-adaptive-N (ASIC resistant)");
                    return;
                case PreMinedValue.TPoS:
                    serializer.Serialize(writer, "TPoS");
                    return;
                case PreMinedValue.Tangle:
                    serializer.Serialize(writer, "Tangle");
                    return;
                case PreMinedValue.ZeroKnowledgeProof:
                    serializer.Serialize(writer, "Zero-Knowledge Proof");
                    return;
                case PreMinedValue.DPoWPoW:
                    serializer.Serialize(writer, "dPoW/PoW");
                    return;
                case PreMinedValue.EPoW:
                    serializer.Serialize(writer, "ePoW");
                    return;
                case PreMinedValue.MFba:
                    serializer.Serialize(writer, "mFBA");
                    return;
            }
            throw new Exception("Cannot marshal type PreMinedValue");
        }

        public static readonly PreMinedValueConverter Singleton = new PreMinedValueConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }
}
