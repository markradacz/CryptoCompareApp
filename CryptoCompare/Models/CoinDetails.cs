



// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using CryptoCompare.Models;
//
//    var welcome = Welcome.FromJson(jsonString);
/*
namespace CryptoCompare.Models
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class CoinDetailsResponse
    {
        [JsonProperty("Response")]
        public string Response { get; set; }

        [JsonProperty("Message")]
        public string Message { get; set; }

        [JsonProperty("Data")]
        public Data Data { get; set; }

        [JsonProperty("Type")]
        public long Type { get; set; }
    }

    public partial class Data
    {
        [JsonProperty("Algorithm")]
        public string Algorithm { get; set; }

        [JsonProperty("ProofType")]
        public string ProofType { get; set; }

        [JsonProperty("BlockNumber")]
        public long BlockNumber { get; set; }

        [JsonProperty("NetHashesPerSecond")]
        public double NetHashesPerSecond { get; set; }

        [JsonProperty("TotalCoinsMined")]
        public long TotalCoinsMined { get; set; }

        [JsonProperty("BlockReward")]
        public double BlockReward { get; set; }

        [JsonProperty("AggregatedData")]
        public AggregatedData AggregatedData { get; set; }

        [JsonProperty("Exchanges")]
        public AggregatedData[] Exchanges { get; set; }
    }

    public partial class AggregatedData
    {
        [JsonProperty("TYPE")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Type { get; set; }

        [JsonProperty("MARKET")]
        public string Market { get; set; }

        [JsonProperty("FROMSYMBOL")]
        public Fromsymbol Fromsymbol { get; set; }

        [JsonProperty("TOSYMBOL")]
        public Tosymbol Tosymbol { get; set; }

        [JsonProperty("FLAGS")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Flags { get; set; }

        [JsonProperty("PRICE")]
        public string Price { get; set; }

        [JsonProperty("LASTUPDATE")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Lastupdate { get; set; }

        [JsonProperty("LASTVOLUME")]
        public string Lastvolume { get; set; }

        [JsonProperty("LASTVOLUMETO")]
        public string Lastvolumeto { get; set; }

        [JsonProperty("LASTTRADEID")]
        public string Lasttradeid { get; set; }

        [JsonProperty("VOLUMEDAY", NullValueHandling = NullValueHandling.Ignore)]
        public string Volumeday { get; set; }

        [JsonProperty("VOLUMEDAYTO", NullValueHandling = NullValueHandling.Ignore)]
        public string Volumedayto { get; set; }

        [JsonProperty("VOLUME24HOUR")]
        public string Volume24Hour { get; set; }

        [JsonProperty("VOLUME24HOURTO")]
        public string Volume24Hourto { get; set; }

        [JsonProperty("OPENDAY", NullValueHandling = NullValueHandling.Ignore)]
        public string Openday { get; set; }

        [JsonProperty("HIGHDAY", NullValueHandling = NullValueHandling.Ignore)]
        public string Highday { get; set; }

        [JsonProperty("LOWDAY", NullValueHandling = NullValueHandling.Ignore)]
        public string Lowday { get; set; }

        [JsonProperty("OPEN24HOUR")]
        public string Open24Hour { get; set; }

        [JsonProperty("HIGH24HOUR")]
        public string High24Hour { get; set; }

        [JsonProperty("LOW24HOUR")]
        public string Low24Hour { get; set; }

        [JsonProperty("LASTMARKET", NullValueHandling = NullValueHandling.Ignore)]
        public string Lastmarket { get; set; }
    }

    public enum Fromsymbol { Btc };

    public enum Tosymbol { Bitusd, Ckusd, Gusd, Tusd, Usd, Wusd };

    public partial class Welcome
    {
        public static CoinDetailsResponse FromJson(string json) => JsonConvert.DeserializeObject<CoinDetailsResponse>(json, CryptoCompare.Models.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Welcome self) => JsonConvert.SerializeObject(self, CryptoCompare.Models.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                FromsymbolConverter.Singleton,
                TosymbolConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class FromsymbolConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Fromsymbol) || t == typeof(Fromsymbol?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "BTC")
            {
                return Fromsymbol.Btc;
            }
            throw new Exception("Cannot unmarshal type Fromsymbol");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Fromsymbol)untypedValue;
            if (value == Fromsymbol.Btc)
            {
                serializer.Serialize(writer, "BTC");
                return;
            }
            throw new Exception("Cannot marshal type Fromsymbol");
        }

        public static readonly FromsymbolConverter Singleton = new FromsymbolConverter();
    }

    internal class TosymbolConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Tosymbol) || t == typeof(Tosymbol?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BITUSD":
                    return Tosymbol.Bitusd;
                case "CKUSD":
                    return Tosymbol.Ckusd;
                case "GUSD":
                    return Tosymbol.Gusd;
                case "TUSD":
                    return Tosymbol.Tusd;
                case "USD":
                    return Tosymbol.Usd;
                case "WUSD":
                    return Tosymbol.Wusd;
            }
            throw new Exception("Cannot unmarshal type Tosymbol");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Tosymbol)untypedValue;
            switch (value)
            {
                case Tosymbol.Bitusd:
                    serializer.Serialize(writer, "BITUSD");
                    return;
                case Tosymbol.Ckusd:
                    serializer.Serialize(writer, "CKUSD");
                    return;
                case Tosymbol.Gusd:
                    serializer.Serialize(writer, "GUSD");
                    return;
                case Tosymbol.Tusd:
                    serializer.Serialize(writer, "TUSD");
                    return;
                case Tosymbol.Usd:
                    serializer.Serialize(writer, "USD");
                    return;
                case Tosymbol.Wusd:
                    serializer.Serialize(writer, "WUSD");
                    return;
            }
            throw new Exception("Cannot marshal type Tosymbol");
        }

        public static readonly TosymbolConverter Singleton = new TosymbolConverter();
    }
}
*/


// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using CryptoCompare.Models;
//
//    var welcome = Welcome.FromJson(jsonString);

namespace CryptoCompare.Models
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class CoinDetailsResponse
    {
        [JsonProperty("Response")]
        public string Response { get; set; }

        [JsonProperty("Message")]
        public string Message { get; set; }

        [JsonProperty("Data")]
        public Data Data { get; set; }

        [JsonProperty("Type")]
        public long Type { get; set; }
    }

    public partial class Data
    {
        [JsonProperty("SEO")]
        public Seo Seo { get; set; }

        [JsonProperty("General")]
        public General General { get; set; }

        [JsonProperty("ICO")]
        public Ico Ico { get; set; }

        [JsonProperty("Subs")]
        public string[] Subs { get; set; }

        [JsonProperty("StreamerDataRaw")]
        public string[] StreamerDataRaw { get; set; }
    }

    public partial class General
    {
        string BasePath = "https://www.cryptocompare.com";

        [JsonIgnore]
        public string CoinImage { get => $"{ this.BasePath }{this.ImageUrl}"; }

        [JsonProperty("Id")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Id { get; set; }

        [JsonProperty("DocumentType")]
        public string DocumentType { get; set; }

        [JsonProperty("H1Text")]
        public string H1Text { get; set; }

        [JsonProperty("DangerTop")]
        public string DangerTop { get; set; }

        [JsonProperty("WarningTop")]
        public string WarningTop { get; set; }

        [JsonProperty("InfoTop")]
        public string InfoTop { get; set; }

        [JsonProperty("Symbol")]
        public string Symbol { get; set; }

        [JsonProperty("Url")]
        public string Url { get; set; }

        [JsonProperty("BaseAngularUrl")]
        public string BaseAngularUrl { get; set; }

        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("ImageUrl")]
        public string ImageUrl { get; set; }

        [JsonProperty("Description")]
        public string Description { get; set; }

        [JsonProperty("Features")]
        public string Features { get; set; }

        [JsonProperty("Technology")]
        public string Technology { get; set; }

        [JsonProperty("TotalCoinSupply")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long TotalCoinSupply { get; set; }

        [JsonProperty("DifficultyAdjustment")]
        public string DifficultyAdjustment { get; set; }

        [JsonProperty("BlockRewardReduction")]
        public string BlockRewardReduction { get; set; }

        [JsonProperty("Algorithm")]
        public string Algorithm { get; set; }

        [JsonProperty("ProofType")]
        public string ProofType { get; set; }

        [JsonProperty("StartDate")]
        public string StartDate { get; set; }

        [JsonProperty("Twitter")]
        public string Twitter { get; set; }

        [JsonProperty("WebsiteUrl")]
        public Uri WebsiteUrl { get; set; }

        [JsonProperty("Website")]
        public string Website { get; set; }

        [JsonProperty("Sponsor")]
        public Sponsor Sponsor { get; set; }

        [JsonProperty("IndividualSponsor")]
        public IndividualSponsor IndividualSponsor { get; set; }

        [JsonProperty("LastBlockExplorerUpdateTS")]
        public long LastBlockExplorerUpdateTs { get; set; }

        [JsonProperty("BlockNumber")]
        public long BlockNumber { get; set; }

        [JsonProperty("BlockTime")]
        public long BlockTime { get; set; }

        [JsonProperty("NetHashesPerSecond")]
        public double NetHashesPerSecond { get; set; }

        [JsonProperty("TotalCoinsMined")]
        public double TotalCoinsMined { get; set; }

        [JsonProperty("PreviousTotalCoinsMined")]
        public long PreviousTotalCoinsMined { get; set; }

        [JsonProperty("BlockReward")]
        public long BlockReward { get; set; }
    }

    public partial class IndividualSponsor
    {
        [JsonProperty("Text")]
        public string Text { get; set; }

        [JsonProperty("Link")]
        public Uri Link { get; set; }

        [JsonProperty("AffiliateLogo")]
        public string AffiliateLogo { get; set; }

        [JsonProperty("ExcludedCountries")]
        public string ExcludedCountries { get; set; }
    }

    public partial class Sponsor
    {
        [JsonProperty("TextTop")]
        public string TextTop { get; set; }

        [JsonProperty("Link")]
        public Uri Link { get; set; }

        [JsonProperty("ImageUrl")]
        public string ImageUrl { get; set; }

        [JsonProperty("ExcludedCountries")]
        public string ExcludedCountries { get; set; }
    }

    public partial class Ico
    {
        [JsonProperty("Status")]
        public string Status { get; set; }

        [JsonProperty("Description")]
        public string Description { get; set; }

        [JsonProperty("TokenType")]
        public string TokenType { get; set; }

        [JsonProperty("Website")]
        public string Website { get; set; }

        [JsonProperty("WebsiteLink")]
        public Uri WebsiteLink { get; set; }

        [JsonProperty("PublicPortfolioUrl")]
        public string PublicPortfolioUrl { get; set; }

        [JsonProperty("PublicPortfolioId")]
        public string PublicPortfolioId { get; set; }

        [JsonProperty("Features")]
        public string Features { get; set; }

        [JsonProperty("FundingTarget")]
        public string FundingTarget { get; set; }

        [JsonProperty("FundingCap")]
        public string FundingCap { get; set; }

        [JsonProperty("ICOTokenSupply")]
        public string IcoTokenSupply { get; set; }

        [JsonProperty("TokenSupplyPostICO")]
        public string TokenSupplyPostIco { get; set; }

        [JsonProperty("TokenPercentageForInvestors")]
        public string TokenPercentageForInvestors { get; set; }

        [JsonProperty("TokenReserveSplit")]
        public string TokenReserveSplit { get; set; }

        [JsonProperty("Date")]
        public long Date { get; set; }

        [JsonProperty("EndDate")]
        public long EndDate { get; set; }

        [JsonProperty("FundsRaisedList")]
        public string FundsRaisedList { get; set; }

        [JsonProperty("FundsRaisedUSD")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long FundsRaisedUsd { get; set; }

        [JsonProperty("StartPrice")]
        public string StartPrice { get; set; }

        [JsonProperty("StartPriceCurrency")]
        public string StartPriceCurrency { get; set; }

        [JsonProperty("PaymentMethod")]
        public string PaymentMethod { get; set; }

        [JsonProperty("Jurisdiction")]
        public string Jurisdiction { get; set; }

        [JsonProperty("LegalAdvisers")]
        public string LegalAdvisers { get; set; }

        [JsonProperty("LegalForm")]
        public string LegalForm { get; set; }

        [JsonProperty("SecurityAuditCompany")]
        public string SecurityAuditCompany { get; set; }

        [JsonProperty("Blog")]
        public string Blog { get; set; }

        [JsonProperty("BlogLink")]
        public Uri BlogLink { get; set; }

        [JsonProperty("WhitePaper")]
        public string WhitePaper { get; set; }

        [JsonProperty("WhitePaperLink")]
        public Uri WhitePaperLink { get; set; }
    }

    public partial class Seo
    {
        [JsonProperty("PageTitle")]
        public string PageTitle { get; set; }

        [JsonProperty("PageDescription")]
        public string PageDescription { get; set; }

        [JsonProperty("BaseUrl")]
        public Uri BaseUrl { get; set; }

        [JsonProperty("BaseImageUrl")]
        public Uri BaseImageUrl { get; set; }

        [JsonProperty("OgImageUrl")]
        public string OgImageUrl { get; set; }

        [JsonProperty("OgImageWidth")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long OgImageWidth { get; set; }

        [JsonProperty("OgImageHeight")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long OgImageHeight { get; set; }
    }

    public partial class Welcome
    {
        public static Welcome FromJson(string json) => JsonConvert.DeserializeObject<Welcome>(json, CryptoCompare.Models.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Welcome self) => JsonConvert.SerializeObject(self, CryptoCompare.Models.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }
}
